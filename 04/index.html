<html>
    <head>
        <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
        <meta content="utf-8" http-equiv="encoding" />
        <title>Default WebGL!</title>
        <style>
            html,
            body {
                background-image: url("bg.jpg");
                background-size: cover;
                margin: 0;
                padding: 0;
                height: 100%;
                overflow: hidden !important;
            }

            #c {
                width: 100%;
                height: 100%;
            }
        </style>
    </head>
    <script
        type="text/javascript"
        src="https://cs460.org/js/glmatrix.js"
    ></script>

    <script id="vertexshader" type="glsl">
        attribute vec3 a_position;

        uniform float u_pointSize;
        uniform mat4 u_transform;

        void main(void) {
            vec4 final_position = u_transform * vec4(a_position, 1.0);

            gl_Position = final_position;
            gl_PointSize = u_pointSize;
        }
    </script>

    <script id="fragmentshader" type="glsl">
        precision mediump float;

        uniform vec4 u_color;

        void main(void) {

          gl_FragColor = u_color;

        }
    </script>

    <script>
        let gl;
        let shaderprogram;

        let a_position;
        let u_color;
        let u_pointSize;
        let u_transform;

        let fishes = [];

        const initShadersAndProgram = () => {
            const c = document.getElementById("c"); // setup canvas
            c.width = window.innerWidth;
            c.height = window.innerHeight;

            gl = c.getContext("webgl"); // setup GL context
            gl.viewport(0, 0, c.width, c.height);

            const v_shader = gl.createShader(gl.VERTEX_SHADER);
            const f_shader = gl.createShader(gl.FRAGMENT_SHADER);

            // compile vertex shader
            gl.shaderSource(v_shader, document.getElementById("vertexshader").innerText);
            gl.compileShader(v_shader);
            if (!gl.getShaderParameter(v_shader, gl.COMPILE_STATUS)) {
                console.log(`Vertex shader compile errror: ${gl.getShaderInfoLog(v_shader)}`);
            }

            // compile fragment shader
            gl.shaderSource(f_shader, document.getElementById("fragmentshader").innerText);
            gl.compileShader(f_shader);
            if (!gl.getShaderParameter(f_shader, gl.COMPILE_STATUS)) {
                console.log(`Fragment shader compile errror: ${gl.getShaderInfoLog(f_shader)}`);
            }

            // attach and link the shaders
            shaderprogram = gl.createProgram();
            gl.attachShader(shaderprogram, v_shader);
            gl.attachShader(shaderprogram, f_shader);
            gl.linkProgram(shaderprogram);
            gl.useProgram(shaderprogram);

            a_position  = gl.getAttribLocation(shaderprogram, "a_position");
            u_color     = gl.getUniformLocation(shaderprogram, "u_color");
            u_pointSize = gl.getUniformLocation(shaderprogram, "u_pointSize");
            u_transform = gl.getUniformLocation(shaderprogram, "u_transform");
        }

        window.onload = function () {
            initShadersAndProgram();
            for (let i = 0; i < 100; i++) {
                const random_color  = [Math.random(), Math.random(), Math.random(), Math.random()];
                const random_offset = [Math.random() - Math.random(), Math.random() - Math.random(), 0];
                const random_scale  = Math.random() * 0.3;
                fishes.push(createFish(random_offset, random_color, random_scale, 1))
            }
            fishes.push(createFish([0, 0, 0], [1, 0, 0, 1], 1, -1, true));
            animate();
        };

        function createFish(offset, color, scale = 1, direction = 1, isMain = false) {
            const vertices = new Float32Array([
                 0.5,  0.0,  0.0, // 0: nose
                 0.2,  0.25, 0.0, // 1: upper body
                -0.2,  0.15, 0.0, // 2: upper tail base
                -0.4,  0.3,  0.0, // 3: upper tail tip
                -0.4, -0.3,  0.0, // 4: lower tail tip
                -0.2, -0.15, 0.0, // 5: lower tail base
                 0.2, -0.25, 0.0  // 6: lower body
            ]);
            const indices = new Uint8Array([
                0, 1, 6, // main body
                1, 2, 6, // upper mid-body
                2, 5, 6, // rear body
                2, 3, 5, // tail top
                3, 4, 5  // tail fin
            ]);

            const body_vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, body_vbo);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            const body_ebo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, body_ebo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

            const eye_vertices =  direction == -1 ? 
                new Float32Array([0.2, -0.2, 0.0]) :
                new Float32Array([0.2, 0.2, 0.0]);

            const eye_vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, eye_vbo);
            gl.bufferData(gl.ARRAY_BUFFER, eye_vertices, gl.STATIC_DRAW);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            return {
                body_vbo: body_vbo,
                body_ebo: body_ebo,
                eye_vbo: eye_vbo,
                offset: offset,
                color: color,
                scale: scale,
                direction: direction,
                isMain: isMain
            }
        }

        const moveFish = (fish) => {
            fish.offset[0] += 0.01 * fish.direction;
            fish.offset[1] += 0.01 * Math.random();
            fish.offset[1] -= 0.01 * Math.random();
            if (fish.direction == 1 && fish.offset[0] >= 1) {
                fish.offset[0] = -1;
            } else if (fish.direction == -1 && fish.offset[0] <= - 1) {
                fish.offset[0] = 1;
            }
        }

        const drawBody = (fish) => {
            gl.bindBuffer(gl.ARRAY_BUFFER, fish.body_vbo);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, fish.body_ebo);

            gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_position);

            const theta = Math.random() * 10 * Math.PI / 100;
            const transform = [
                fish.direction * fish.scale * Math.cos(theta),  Math.sin(theta), 0, 0,
                -Math.sin(theta), fish.direction * fish.scale * Math.cos(theta), 0, 0,
                0, 0, fish.direction * fish.scale, 0,
                fish.offset[0], fish.offset[1], fish.offset[2], 1
            ];
            gl.uniformMatrix4fv(u_transform, false, new Float32Array(transform));

            const t = performance.now();
            const a = 0.6 + 0.4 * Math.sin(t * 2.0);
            let color = new Float32Array([
                fish.color[0] * (0.3 + 0.2 * Math.sin(t + 0.0)),
                fish.color[1] * (0.6 + 0.2 * Math.sin(t + 2.0)),
                fish.color[2] * (0.9 + 0.1 * Math.sin(t + 4.0)),
                a
            ]);
            

            if (fish.isMain) {
                color = [1.0, 0.0, 0.0, 0.7];
            }
            gl.uniform4fv(u_color, color);

            gl.drawElements(gl.TRIANGLES, 15, gl.UNSIGNED_BYTE, 0);
        }

        const drawEye = (fish) => {
            gl.bindBuffer(gl.ARRAY_BUFFER, fish.eye_vbo);

            gl.vertexAttribPointer(a_position, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(a_position);

            gl.uniform4fv(u_color, new Float32Array([0, 0, 0, 0.5]));
            gl.uniform1f(u_pointSize, fish.scale * 20);

            gl.drawArrays(gl.POINTS, 0, 1);
        }

        function animate() {
            requestAnimationFrame(animate);

            gl.clearColor(0, 0, 0, 0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.disable(gl.DEPTH_TEST)
    
            for (let r = 0; r < fishes.length; r++) {
                let fish = fishes[r];

                moveFish(fish);
                drawBody(fish);
                drawEye(fish);
            }
        }
    </script>
    <body>
        <canvas id="c"></canvas>
    </body>
</html>
